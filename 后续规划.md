# 后续规划

## 第一阶段

### 内容

制定下面的规划的目的是为了让该组件可扩展性更强，同时代码实现上更加优雅。

1、针对`L1`提供扩展点，支持根据需要扩展不同的`L1`实现。

2、针对`L2`提供扩展点，支持根据需要扩展不同的`L2`实现。

3、针对`缓存变更通知`提供扩展点，支持通过kafka、rocketmq等其他消息中间件来进行`缓存变更通知`。

### 状态
`2020-07-09 已完成`


## 第二阶段

### 内容
1、在高并发场景下的实战

2、只用二级缓存Redis的实战

3、一二级缓存结合使用的实战

### 状态
`2020-10-09 已完成`

## 第三阶段

### 内容
1、支持批量getOrLoad
> 实际项目中存在大量循环获取单个缓存的场景，多次交互性能受损，业务代码不够优雅，故提供批量获取功能更好的服务业务

2、支持批量put


### 状态
`2021-03-25 已完成`

## 第四阶段

### 内容
1、热key的自动识别功能
> 现状：目前每次大促都是通过人为配置相关热key到本地缓存。该方式需要人工介入，且容易出现误操作。
> 
> 目标：通过自动识别热key，来判断是否走本地缓存，无需人为配置热key到本地缓存，一方面可释放人力，另一方面可预防突发流量打垮下游服务。
> 
> 热key探测方案：
> - 自研（第二个版本的规划）
> - 京东hotkey（第一个版本采用该方式）
> - 阿里sentinel的热点参数限流


### 状态
已完成部分


## 第五阶段

### 内容
1、支持不同维度的缓存配置各自的缓存类型
> 目前缓存类型的配置维度太大，导致一个应用只能配置一个缓存类型。

2、支持只使用二级缓存Redis时给不同维度的缓存设置不同的过期时间

### 状态
待处理



## 第六阶段（重点）

### 内容
1、缓存的可视化管理+监控（有监控才有方向）

始于架构，精于治理。

> 现状：目前对于应用中的缓存现状是未知的，无法分析本地缓存的命中率，哪些key存在缓存穿透（次数？），哪些缓存走了本地缓存，缓存数量等等。
> 
> 目标：通过一个dashboard面板将缓存可视化，便于管控。（结合Prometheus监控体系+Grafana监控数据展示 ）


### 状态
待处理

## 第七阶段

### 内容
1、定义KeyBuilder来统一定义缓存key的构建，提升系统的扩展性


### 状态
待处理

